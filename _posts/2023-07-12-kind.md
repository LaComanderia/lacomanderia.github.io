---
tags: ["kubernetes", "docker", "kind"]
title: "Levanta un cl√∫ster de Kubernetes en menos de 5 minutos usando Kind"
layout: splash
permalink: /cluster-de-kubernetes-usando-kind/
header:
  overlay_color: "#000"
  overlay_filter: "0.5"
  overlay_image: https://img.freepik.com/foto-gratis/enviar-botella_1204-315.jpg?t=st=1651681113~exp=1651681713~hmac=cd96f524a7fc7ba64b2fad6aab3e56390f11dcafdc53ef826a1eb1766b16058f&w=1060
excerpt: "Crearemos un cl√∫ster de Kubernetes local para realizar pruebas o aprender a usar esta tecnolog√≠a. Para facilitar esta tarea existe una herramienta llamada Kind, que despliega un cl√∫ster de Kubernetes de varios nodos usando contenedores Docker."
---

<img src="https://d33wubrfki0l68.cloudfront.net/d0c94836ab5b896f29728f3c4798054539303799/9f948/logo/logo.png" width="500">


## Acerca de Kind
Kind viene de "**K**ubernetes **In D**ocker" y con este t√≠tulo tenemos claro que hace esta herramienta. Kind permite levantar un cl√∫ster de Kubernetes de manera local usando contendores Docker.

Voy a explicar el funcionamiento de Kind "al estilo compadre" de primeras para que se entienda mejor. Kind permite utilizar contenedores Docker como nodos del cl√∫ster K8S* para as√≠ tener un entorno local multinodo en un sola m√°quina. En la realidad los nodos de un cl√∫ster son m√°quinas, ya sean f√≠sicas o virtuales. Lo bueno de Kind es que nos ahorra el tener que crear estas m√°quinas y a√±adirlas manualmente. Adem√°s, si quisi√©ramos hacerlo con m√°quinas virtuales, el consumo de recursos aumentar√≠a, puesto que estas consumen m√°s que los contenedores.

Otra opci√≥n ser√≠a crear a mano los contendores y a√±adirlos al cl√∫ster, lo que a mi parecer es una tonter√≠a puesto que Kind hace este trabajo por nosotros y, si no tenemos los conocimientos suficientes en Kubernetes, podr√≠amos tener fallos a la hora de agregar dichos nodos.

Resumiendo, teneniendo una m√°quina con Docker y Kind instalados tenemos un cl√∫ster de kubernetes en local con tantos nodos como queramos.

La imagen que usan estos contendores Docker es una propia desarrollada por ellos basada en Ubuntu 20.10, que utiliza como gestor de sistema systemd y que trae todos los componentes de Kubernetes instalados y funcionando. Realmente, cada contenedor a su vez corre los componentes necesarios de Kubernetes en otros contenedores. Algo as√≠ como una virtualizaci√≥n anidada.

## ¬øPor q√∫e usar Kind?

## Instalaci√≥n y creaci√≥n del cl√∫ster.

Comenzamos descargando Kind desde su p√°gina oficial. Usamos el comando curl junto con el par√°metro *-L* (indica la localizaci√≥n donde se guardar√° el fichero) y *-o* (indicamos el nombre con el que guardaremos dicho fichero.)

~~~bash
curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.12.0/kind-linux-amd64
~~~

Le damos permiso de ejecuci√≥n al fichero que acabamos de descargar.

~~~bash
chmod +x ./kind
~~~

Por √∫ltimo moveremos el fichero a una ruta dentro de la variable *$PATH* para que sea accesible sin necesidad de poner la ruta completa. Tambi√©n podemos agregar una ruta personalizada a esta variable.

~~~bash
mv ./kind /usr/local/bin
~~~

He de destacar que yo estoy usando un sistema operativo basado en Red Hat (m√°s concretamente un Rocky Linux) y la ruta anterior no se encuantra en *$PATH*. La a√±adiremos nosotros con el siguiente comando.

~~~bash
export PATH=$PATH:/<ruta>
~~~

Ahora comprobamos que lo tenemos todo instalando comprobando la versi√≥n de Kind instalada con el comando *kind version*. El resultado tiene que ser algo parecido a esto:

~~~bash
kind version
kind v0.10.0 go1.15.7 linux/amd64
~~~

Empezaremos creando el cl√∫ster. El siguiente comando nos crear√° un cl√∫ster de un s√≥lo nodo.
~~~bash
kind create cluster
~~~
Y obtendremos la siguiente salida.
~~~bash
Creating cluster "kind" ...
 ‚úì Ensuring node image (kindest/node:v1.20.2) üñº
 ‚úì Preparing nodes üì¶
 ‚úì Writing configuration üìú
 ‚úì Starting control-plane üïπÔ∏è
 ‚úì Installing CNI üîå
 ‚úì Installing StorageClass üíæ
Set kubectl context to "kind-kind"
You can now use your cluster with:

kubectl cluster-info --context kind-kind

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community üôÇ
~~~

Ahora comprobamos los contendores que tenemos corriendo.
~~~bash
docker ps
CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS          PORTS                       NAMES
9905e6c2329a   kindest/node:v1.20.2   "/usr/local/bin/entr‚Ä¶"   40 seconds ago   Up 29 seconds   127.0.0.1:46579->6443/tcp   kind-control-plane
~~~

Como vemos tenemos un contendor Docker efectuando la tarea de nodo "control plane" y la de "master"de Kubernetes.

Ya tendr√≠amos el cl√∫ster creado. Ahora para administrarlo tendremos que descargar kubectl. En sistemas basados en Red Hat se usa el administrador de paquetes *Yum*, as√≠ que las siguientes l√≠neas s√≥lo son v√°lidas para este tipo de sistemas operativos.
~~~bash
cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
sudo yum install -y kubectl
~~~

Si est√°s usando otro tipo de sistema operativo en la documentaci√≥n de Kubectl tienes paso a paso lo que tienes que hacer.


En Kubectl hay que exportar una clave del cl√∫ster a la variable de entorno *$KUBECONFIG* para que kubectl pueda conectarse al c√∫ster de kubernetes. En nuestro caso Kind lo hace s√≥lo cuando inciamos el cl√∫ster.

Para comprobar que efectivamente estamos corriendo un cl√∫ster de kubernetes obtendremos el estado de los nodos.

~~~bash
kubectl get nodes
~~~

Y tendremos que obtenedor algo parecido a esto.
~~~bash
NAME                 STATUS   ROLES                  AGE     VERSION
kind-control-plane   Ready    control-plane,master   2m49s   v1.20.2
~~~

Como dijimos antes tenemos un cl√∫ster de un s√≥lo nodo. Ahora vamos a borrar el cl√∫ster actual y vamos a levantar uno con varios nodos.

Empezamos borrando el cl√∫ster actual.

~~~bash
kind delete cluster
~~~

Ahora vamos a crear un fichero *.yaml* donde vamos a indicar cuantos nodos queremos levantar.

~~~bash
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
- role: worker
- role: worker
~~~

Un nodo *control-plane* administra las cargas de trabajo del resto de nodos y en √©l se ejecutan todos los componentes necesarios como etcd, etc... Este tipo de nodo no corre ning√∫n pod definido por nosotros.

Los nodos *worker* son aquellos dedicados a ejecutar las aplicaciones definidas por el usuario a trav√©s de los pods.

Guardamos el fichero y ejecutamos el siguiente comando.
~~~bash
kind create cluster --config kind-config.yaml
~~~

*kind-config* es el nombre del fichero que cree con la configuraci√≥n anterior.

Ahora comprobamos los nodos con kubectl ejecutando el mismo comando que antes.

~~~bash
NAME                 STATUS   ROLES                  AGE     VERSION
kind-control-plane   Ready    control-plane,master   3m16s   v1.20.2
kind-worker          Ready    <none>                 2m42s   v1.20.2
kind-worker2         Ready    <none>                 2m42s   v1.20.2
~~~

## Primer despliegue.
Para comprobar que todo funciona correctamente crearemos un primer despliegue usando varios pods de nginx. Para ello vamos a definir un *deployment* con las caracter√≠sticas del pod y cu√°ntas r√©plicas queremos hacer de dichos pods.


*K8S: abreviatura para referirnos a Kubernetes. Viene de seleccionar la primera y la √∫ltima letra de la palabra y poner entre medias el total num√©rico de letras restantes (ubernete). Su pronunciaci√≥n ser√≠a algo como "keichs".